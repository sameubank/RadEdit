global.fs = require 'fs'
global.jade = require 'jade'
global.events = require 'events'
global.coffee = require 'coffee-script'

global.views = {}
global.publicContent = {}
global.isDevMode = true
global.isWindows = /win/i.test(process.platform)
global.startTime = new Date

jade.views = {}
fs.tree = {}

APP_RESTART_DELAY = 10
CLIENT_REFRESH_DELAY = 20
PUBLIC_FILE_COMPILE_DELAY = 50
DIR_WALK_INTERVAL = 1000

mime =
	html: 'text/html'
	css: 'text/css'
	js: 'text/javascript'
	png: 'image/png'
	jpg: 'image/jpg'
	gif: 'image/gif'
	json: 'text/json'
	ico: 'image/x-icon'

libRel = __dirname.substr documentRoot.length + 1
libRel = libRel.replace /\\/g, '/'
publicRel = libRel.replace /lib$/, 'public'
publicAssets =
	"/code.css": [
		"editor.css"
	],
	"/code.js": [
		"lib/logging.js"
		"lib/strings.js"
		"lib/collections.js"
		"lib/dom.js"
		"lib/events.js"
		"lib/ajax.js"
		"lib/io.js"
		"codemirror.js"
		"modes/coffeescript.js"
		"modes/css.js"
		"modes/htmlmixed.js"
		"modes/jade.js"
		"modes/javascript.js"
		"modes/less.js"
		"modes/sass.js"
		"modes/sql.js"
		"modes/xml.js"
		"editor/storage.coffee"
		"editor/icons.coffee"
		"editor/key_bindings.coffee"
		"editor/menu.coffee"
		"editor/refresh.coffee"
		"editor/tree.coffee"
		"editor/code.coffee"
	]
for href, components of publicAssets
	for componentRel, index in components
		components[index] = publicRel + '/' + componentRel
	config.public[href] = components

modifiedTimes = {}

ignorePattern = '.\n' + fs.readFileSync documentRoot + '/.gitignore'
ignorePattern = ignorePattern.replace /(^\s|\s+$)/, ''
ignorePattern = ignorePattern.replace /\./g, '\\.'
ignorePattern = ignorePattern.replace /\*/g, '.*'
ignorePattern = ignorePattern.replace /\s+/g, '|'
ignorePattern = new RegExp "^(#{ignorePattern})$"

modulesPattern = /(^|\/)node_modules\//
publicPattern = /(^|\/)public\//
viewsPattern = /(^|\/)views\//

loadFiles = ->
	walk documentRoot, checkFile, checkDir
	buildTree()
	setTimeout loadFiles, DIR_WALK_INTERVAL


# Load application files first because other files reference them.
process.nextTick ->
	walk documentRoot + '/src/app', checkFile

# Load all files
process.nextTick loadFiles


class Node
	constructor: (@rel) ->
		@name = @rel.replace /.*\//, ''

getNode = (rel) ->
	node = fs.tree[rel]
	if not node
		node = fs.tree[rel] = new Node rel
	return node

buildTree = ->
	string = treeString fs.tree['']
	if string isnt fs.treeString
		fs.treeString = string
		io.sockets.emit 'code:tree', string

exports.buildTree = buildTree

treeString = (node, maxDepth = 100) ->
	if node
		string = node.name
		if node.files and maxDepth
			maxDepth--
			string += '/'
			string += (treeString file, maxDepth for file in node.files).join '|'
			string += '\\'
		string


checkFile = (path, stat) ->
	modifiedTime = stat.mtime.getTime()
	previousTime = modifiedTimes[path]
	recentlyModified = modifiedTime > previousTime

	if recentlyModified or not previousTime
		modifiedTimes[path] = modifiedTime
		loadFile path, previousTime


checkDir = (path, files) ->
	rel = path.substr(documentRoot.length + 1)
	dir = getNode rel
	dir.files = []
	for filename in files
		if not ignorePattern.test filename
			dir.files.push getNode rel + (if rel then '/' else '') + filename


refreshClients = (changed) ->
	clearTimeout refreshClients.t
	refreshClients.t = setTimeout(->
		io.sockets.emit 'refresh', changed
	, CLIENT_REFRESH_DELAY)


restartApp = (rel) ->
	log.warn "Critical file changed (#{rel}). Restarting app."
	setTimeout process.exit, APP_RESTART_DELAY

loadFile = (path, isReload) ->
	rel = path.substr documentRoot.length + 1

	if isReload
		log "Updated: #{rel}"

	# Load public files.
	if publicPattern.test rel
		fs.readFile path, (err, content) ->
			loadPublic rel, content
			extension = getExtension path
			type = mime[extension] or 'text/html'
			href = rel.replace publicPattern, '$1'
			href = href.replace modulesPattern, '$1'
			href = href.replace /\.html$/, ''
			href = href.replace /\.coffee$/, '.js'
			app.on 'GET', '/' + href, (request, response) ->
				response.writeHead 200,
					'Content-Type': type
				response.end publicAssets.content[rel]
			refreshClients 'public'

	# Load jade views for the server.
	else if (getExtension rel) is 'jade'
		# Load dependent views
		loadView = (name, path) ->
			fs.readFile path, (err, content) ->
				view = jade.compile(content,
					filename: path
				)
				views[name] = view
				views[name].path = path
				refreshClients 'views'

		name = rel.replace /\.jade$/, ''
		name = name.replace modulesPattern, '$1'
		name = name.replace viewsPattern, '$1'
		loadView name, path

		for otherName of views
			if otherName isnt name
				loadView otherName, views[otherName].path

	# Load modules
	else
		path = path.replace(/\//g, "\\") if isWindows
		if /(coffee|js|json)$/.test path
			# If it's not the first time, we may need to reload or restart.
			module = require.cache[path]
			if module
				# Reloadable modules have an unload function.
				if module.unload
					module.unload()
				# Non-reloadable modules require an application restart.
				else if isReload
					return restartApp rel
			else
				delete require.cache[path]
				require path
				refreshClients 'module'

exports.loadFile = loadFile


# Recursively walk a directory, calling functions on each file and directory.
walk = (dir, fileCallback, dirCallback) ->
	fs.readdir dir, (err, files) ->
		dirCallback dir, files if dirCallback
		if err
			return
		files.forEach (filename) ->
			if not ignorePattern.test filename
				path = dir + "/" + filename
				fs.stat path, (err, stat) ->
					isDirectory = stat.isDirectory()
					if isDirectory
						walk path, fileCallback, dirCallback
					else
						fileCallback path, stat if fileCallback


publicAssets =
	content: {}
	parents: {}
	groups: {}
	timeouts: {}


loadPublic = (rel, content) ->
	if /\.coffee$/.test rel
		try
			content = coffee.compile('' + content)
			content = content.replace(/^\(function\(\) \{/, '')
			content = content.replace(/\}\)\.call\(this\);[\r\n]*$/, '')
		catch e
			log.debug "Can't compile #{rel}"
			log.error e
	publicAssets.content[rel] = content
	if groups = publicAssets.parents[rel]
		for group in groups
			compilePublic group
			clearTimeout publicAssets.timeouts[group]
			publicAssets.timeouts[group] = setTimeout( ->
				compilePublic group
			, PUBLIC_FILE_COMPILE_DELAY)


compilePublic = (group) ->
	files = config.public[group]
	code = ''
	for file in files
		code += "/* FILE: #{file} */\n"
		code += publicAssets.content[file]
	publicAssets.content[group] = code

	type = mime[getExtension group]
	app.on "GET", group, (request, response) ->
		response.set "Content-Type", type
		response.send publicAssets.content[group]

	refreshClients 'public'


mapPublicAssets = ->
	groups = config.public
	for group, files of groups
		for file in files
			list = publicAssets.parents[file] or (publicAssets.parents[file] = [])
			list.push group if list.indexOf(group) < 0


getExtension = (file) ->
	return file.replace /.*\./, ''


mapPublicAssets()